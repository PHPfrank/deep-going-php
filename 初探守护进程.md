# 什么是守卫进程？
守护进程（daemon）是指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。比如apache或者mysql等服务启动后，就会以守护进程的方式进驻在内存中。守护进程在后台运行，类似于Windows中的系统服务。  
总结就是三个特点：
1.在后台运行2.与启动他的进程脱离3.无须控制终端。


# linux中守卫进程的实现方式
常用的实现方式是fork() -> setsid() -> fork()  
来看一下具体的过程：  
1、fork()创建子进程，父进程exit()退出  

这是创建守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。

2、在子进程中调用 setsid() 函数创建新的会话  

在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来。

3、再次 fork() 一个子进程并让父进程退出。 

现在，进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端，可以通过 fork() 一个子进程，该子进程不是会话首进程，该进程将不能重新打开控制终端。退出父进程。

# php程序实现守卫进程的方式

1.使用nohup命令 , 比如 nohup php task.php &  

默认情况下，代码中echo或者print_r之类输出的文本会被输出到php代码同级目录的nohup.out文件中。如果你用exit命令或者关闭按钮等正常手段关闭终端，该进程不会被关闭，依然会在后台持续运行。但是如果终端遇到异常退出或者终止，该php进程也会随即退出。本质上也并非稳定可靠的daemon方案。

2.在命令后添加一个&符号，比如 php task.php &  
这个方法的缺点在于 如果terminal终端关闭，无论是正常关闭还是非正常关闭，这个php进程都会随着终端关闭而关闭，其次是代码中如果有echo或者print_r之类的输出文本，会被输出到当前的终端窗口中。

3.编写php代码使用fork和setsid来实现
```
<?php
    // 一次fork  
    $pid = pcntl_fork();
    if ( $pid < 0 ) {
	  exit( ' fork error. ' );
	} else if( $pid > 0 ) {
	  exit( ' parent process. ' );
	}
	// 将当前子进程提升会会话组组长 这是至关重要的一步 
	if ( ! posix_setsid() ) {
	  exit( ' setsid error. ' );
	}
	// 二次fork
	$pid = pcntl_fork();
	if( $pid < 0 ){
	  exit( ' fork error. ' );
	} else if( $pid > 0 ) {
	  exit( ' parent process. ' );
	}
	
	// 真正的逻辑代码们 下面仅仅写个循环以示例
	for( $i = 1 ; $i <= 100 ; $i++ ){
	  sleep( 1 );
	  file_put_contents( 'daemon.log', $i, FILE_APPEND );
	}
?>

```