# 什么是守卫进程？
守护进程（daemon）是指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。比如apache或者mysql等服务启动后，就会以守护进程的方式进驻在内存中。守护进程在后台运行，类似于Windows中的系统服务。  
总结就是三个特点：
1.在后台运行2.与启动他的进程脱离3.无须控制终端。


# linux中守卫进程的实现方式
常用的实现方式是fork() -> setsid() -> fork()  
来看一下具体的过程：  
1、fork()创建子进程，父进程exit()退出  

这是创建守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。

2、在子进程中调用 setsid() 函数创建新的会话  

在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来。

3、再次 fork() 一个子进程并让父进程退出。 

现在，进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端，可以通过 fork() 一个子进程，该子进程不是会话首进程，该进程将不能重新打开控制终端。退出父进程。

# php程序实现守卫进程的方式

1.使用nohup命令 , 比如 nohup php task.php &  

默认情况下，代码中echo或者print_r之类输出的文本会被输出到php代码同级目录的nohup.out文件中。如果你用exit命令或者关闭按钮等正常手段关闭终端，该进程不会被关闭，依然会在后台持续运行。但是如果终端遇到异常退出或者终止，该php进程也会随即退出。本质上也并非稳定可靠的daemon方案。

2.在命令后添加一个&符号，比如 php task.php &  
这个方法的缺点在于 如果terminal终端关闭，无论是正常关闭还是非正常关闭，这个php进程都会随着终端关闭而关闭，其次是代码中如果有echo或者print_r之类的输出文本，会被输出到当前的终端窗口中。

3.
编写php代码使用fork和setsid来实现
```
<?php  
/**  
* 后台脚本控制类 
*/  
class DaemonCommand{  
   
    private $info_dir="/tmp";  
    private $pid_file="";  
    private $terminate=false; //是否中断  
    private $workers_count=0;  
    private $gc_enabled=null;  
    private $workers_max=8; //最多运行8个进程  
   
    public function __construct($is_sington=false,$user='nobody',$output="/dev/null"){  
   
            $this->is_sington=$is_sington; //是否单例运行，单例运行会在tmp目录下建立一个唯一的PID  
            $this->user=$user;//设置运行的用户 默认情况下nobody  
            $this->output=$output; //设置输出的地方  
            $this->checkPcntl();  
    }  
    //检查环境是否支持pcntl支持  
    public function checkPcntl(){  
        if ( ! function_exists('pcntl_signal_dispatch')) {  
            // PHP < 5.3 uses ticks to handle signals instead of pcntl_signal_dispatch  
            // call sighandler only every 10 ticks  
            declare(ticks = 10);  
        }  
   
        // Make sure PHP has support for pcntl  
        if ( ! function_exists('pcntl_signal')) {  
            $message = 'PHP does not appear to be compiled with the PCNTL extension.  This is neccesary for daemonization';  
            $this->_log($message);  
            throw new Exception($message);  
        }  
        //信号处理  
        pcntl_signal(SIGTERM, array(__CLASS__, "signalHandler"),false);  
        pcntl_signal(SIGINT, array(__CLASS__, "signalHandler"),false);  
        pcntl_signal(SIGQUIT, array(__CLASS__, "signalHandler"),false);  
   
        // Enable PHP 5.3 garbage collection  
        if (function_exists('gc_enable'))  
        {  
            gc_enable();  
            $this->gc_enabled = gc_enabled();  
        }  
    }  
   
    // daemon化程序  
    public function daemonize(){  
   
        global $stdin, $stdout, $stderr;  
        global $argv;  
   
        set_time_limit(0);  
   
        // 只允许在cli下面运行  
        if (php_sapi_name() != "cli"){  
            die("only run in command line mode\n");  
        }  
   
        // 只能单例运行  
        if ($this->is_sington==true){  
   
            $this->pid_file = $this->info_dir . "/" .__CLASS__ . "_" . substr(basename($argv[0]), 0, -4) . ".pid";  
            $this->checkPidfile();  
        }  
   
        umask(0); //把文件掩码清0  
   
        if (pcntl_fork() != 0){ //是父进程，父进程退出  
            exit();  
        }  
   
        posix_setsid();//设置新会话组长，脱离终端  
   
        if (pcntl_fork() != 0){ //是第一子进程，结束第一子进程     
            exit();  
        }  
   
        chdir("/"); //改变工作目录  
   
        $this->setUser($this->user) or die("cannot change owner");  
   
        //关闭打开的文件描述符  
        fclose(STDIN);  
        fclose(STDOUT);  
        fclose(STDERR);  
   
        $stdin  = fopen($this->output, 'r');  
        $stdout = fopen($this->output, 'a');  
        $stderr = fopen($this->output, 'a');  
   
        if ($this->is_sington==true){  
            $this->createPidfile();  
        }  
   
    }  
    //--检测pid是否已经存在  
    public function checkPidfile(){  
   
        if (!file_exists($this->pid_file)){  
            return true;  
        }  
        $pid = file_get_contents($this->pid_file);  
        $pid = intval($pid);  
        if ($pid > 0 && posix_kill($pid, 0)){  
            $this->_log("the daemon process is already started");  
        }  
        else {  
            $this->_log("the daemon proces end abnormally, please check pidfile " . $this->pid_file);  
        }  
        exit(1);  
   
    }  
    //----创建pid  
    public function createPidfile(){  
   
        if (!is_dir($this->info_dir)){  
            mkdir($this->info_dir);  
        }  
        $fp = fopen($this->pid_file, 'w') or die("cannot create pid file");  
        fwrite($fp, posix_getpid());  
        fclose($fp);  
        $this->_log("create pid file " . $this->pid_file);  
    }  
   
    //设置运行的用户  
    public function setUser($name){  
   
        $result = false;  
        if (empty($name)){  
            return true;  
        }  
        $user = posix_getpwnam($name);  
        if ($user) {  
            $uid = $user['uid'];  
            $gid = $user['gid'];  
            $result = posix_setuid($uid);  
            posix_setgid($gid);  
        }  
        return $result;  
   
    }  
    //信号处理函数  
    public function signalHandler($signo){  
   
        switch($signo){  
   
            //用户自定义信号  
            case SIGUSR1: //busy  
            if ($this->workers_count < $this->workers_max){  
                $pid = pcntl_fork();  
                if ($pid > 0){  
                    $this->workers_count ++;  
                }  
            }  
            break;  
            //子进程结束信号  
            case SIGCHLD:  
                while(($pid=pcntl_waitpid(-1, $status, WNOHANG)) > 0){  
                    $this->workers_count --;  
                }  
            break;  
            //中断进程  
            case SIGTERM:  
            case SIGHUP:  
            case SIGQUIT:  
   
                $this->terminate = true;  
            break;  
            default:  
            return false;  
        }  
   
    }  
    /** 
    *开始开启进程 
    *$count 准备开启的进程数 
    */  
    public function start($count=1){  
   
        $this->_log("daemon process is running now");  
        pcntl_signal(SIGCHLD, array(__CLASS__, "signalHandler"),false); // if worker die, minus children num  
        while (true) {  
            if (function_exists('pcntl_signal_dispatch')){  
   
                pcntl_signal_dispatch();  
            }  
   
            if ($this->terminate){  
                break;  
            }  
            $pid=-1;  
            if($this->workers_count<$count){  
   
                $pid=pcntl_fork();  
            }  
   
            if($pid>0){  
   
                $this->workers_count++;  
   
            }elseif($pid==0){  
   
                // 这个符号表示恢复系统对信号的默认处理  
                pcntl_signal(SIGTERM, SIG_DFL);  
                pcntl_signal(SIGCHLD, SIG_DFL);  
                if(!empty($this->jobs)){  
                    while($this->jobs['runtime']){  
                        if(empty($this->jobs['argv'])){  
                            call_user_func($this->jobs['function'],$this->jobs['argv']);  
                        }else{  
                            call_user_func($this->jobs['function']);  
                        }  
                        $this->jobs['runtime']--;  
                        sleep(2);  
                    }  
                    exit();  
   
                }  
                return;  
   
            }else{  
   
                sleep(2);  
            }  
   
   
        }  
   
        $this->mainQuit();  
        exit(0);  
   
    }  
   
    //整个进程退出  
    public function mainQuit(){  
   
        if (file_exists($this->pid_file)){  
            unlink($this->pid_file);  
            $this->_log("delete pid file " . $this->pid_file);  
        }  
        $this->_log("daemon process exit now");  
        posix_kill(0, SIGKILL);  
        exit(0);  
    }  
   
    // 添加工作实例，目前只支持单个job工作  
    public function setJobs($jobs=array()){  
   
        if(!isset($jobs['argv'])||empty($jobs['argv'])){  
   
            $jobs['argv']="";  
   
        }  
        if(!isset($jobs['runtime'])||empty($jobs['runtime'])){  
   
            $jobs['runtime']=1;  
   
        }  
   
        if(!isset($jobs['function'])||empty($jobs['function'])){  
   
            $this->log("你必须添加运行的函数！");  
        }  
   
        $this->jobs=$jobs;  
   
    }  
    //日志处理  
    private  function _log($message){  
        printf("%s\t%d\t%d\t%s\n", date("c"), posix_getpid(), posix_getppid(), $message);  
    }  
   
}  
   
//调用方法1  
$daemon=new DaemonCommand(true);  
$daemon->daemonize();  
$daemon->start(2);//开启2个子进程工作  
work();  
   
   
   
   
//调用方法2  
$daemon=new DaemonCommand(true);  
$daemon->daemonize();  
$daemon->addJobs(array('function'=>'work','argv'=>'','runtime'=>1000));//function 要运行的函数,argv运行函数的参数，runtime运行的次数  
$daemon->start(2);//开启2个子进程工作  
   
//具体功能的实现  
function work(){  
      echo "测试1";  
}  
?>
```